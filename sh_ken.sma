// Ken!!! From Street Fighter Games and Series!!sage
// Uppercut is based on hero Scorpion by ReVeNgIsT/yang/vittu

/* CVARS - copy and paste to shconfig.cfg

//Ken Masters
ken_level 0
ken_timer 0.1			//How often (seconds) to run the loop 0.1
ken_duration 1.2		//How long the Shoryuken lasts 1.2
ken_thrust 125			//The upward boost every loop 125
ken_maxspeed 400		//Max x and y speeds (while in air) 400
ken_xymult 1.05			//Multiplies the current x,y vector when moving 1.05
ken_cooldown 6			// Must wait for # seconds till next shot is available (default 6)
ken_maxdamage 100		// Damage of uppercut (default 100)
ken_vicheight 380		// Max height of victim blown (default 380)
ken_radius 300			// Radius of effect if no Shoryuken victim (def=300)

*//*

	Change Log:
	------------------
	v 0.1.4 beta - May 21, 2015 - heliumdream
		- added function distance_to_ground(id) to properly calculate player z-height. -credit: jimaway
		- changed modified_shoryuken() to base its height off this new function instead of origin vec[2]	

	v 0.1.3 beta - May 16, 2015 - heliumdream
		- expansive usability update 
		- renamed "Ken Masters"		
		- cleaned up code; updated legacy calls; removed prethink and posthink;
		- changed upcheight to thrust (and fixed it) and upcheight2 to vicheight
		- remodelled script after the ironman jetpack hero, using it's movement to make the Ken Masters power feel more like a real Shoryuken.
		- added gAirFlag and handling to recognize when your in midair; allowing for downward swoops 
		- moved explode_radius check from on keydown to ken_end. 		
		- created modified_shoryuken() and switch cases for modifying global variables based on z-height (vec[2])
			- note: the switch cases are hardcoded and use relative values. tinker at your own risk. 

	v 0.1.2 beta - May 13, 2015 - heliumdream
		- changed hero design for flavor
		- added explode_radius check on keydown
		- removed blink code, radius check allows for more friendly hit detection
		- considering expansive usability update

	v 0.1.1 beta - Jan 08, 2007	- heliumdream
		- added blink code; users noted that the shoryuken was very hard to hit with otherwise

*/


// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1

#include <amxmod>
#include <superheromod>
#include <Vexd_Utilities>
#include <hlsdk_const>

// GLOBAL VARIABLES
new gHeroID
new const gHeroName[] = "Ken Masters"
new bool:gJetPackRunning[SH_MAXSLOTS+1]
new gSpriteFire

new Float:gThrust, Float:gMaxSpeed, Float:gMultiplier, gMaxDamage, gAirFlag
new pCvarTimer, pCvarDuration, pCvarThrust, pCvarMaxSpeed, pCvarXyMult, pCvarCooldown, pCvarMaxDamage, pCvarRadius 		//pCvarVicHeight - unused. tag mismatch issue. 

#if SEND_COOLDOWN
new Float:KenUsedTime[SH_MAXSLOTS+1]
#endif
//----------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Iron Man", SH_VERSION_STR, "{HOJ} Batman/JTP10181")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel = register_cvar("ken_level", "0")
	pCvarTimer = register_cvar("ken_timer", "0.1")
	pCvarDuration = register_cvar("ken_duration", "1.6")
	pCvarThrust = register_cvar("ken_thrust", "125")
	pCvarMaxSpeed = register_cvar("ken_maxspeed", "400")
	pCvarXyMult = register_cvar("ken_xymult", "1.05")
	pCvarCooldown = register_cvar("ken_cooldown", "5")
	pCvarMaxDamage = register_cvar("ken_maxdamage", "800")
	register_cvar("ken_vicheight", "600")
	pCvarRadius = register_cvar("ken_radius", "300")

	// FIRE THE EVENTS TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel)
	sh_set_hero_info(gHeroID, "Shoryuken", "Uppercut - Use height to go faster and deal more damage")
	sh_set_hero_bind(gHeroID)
}
//----------------------------------------------------------------------------------------------
public plugin_precache()
{
	precache_sound("shmod/kenshoryuken.wav")
	precache_sound("player/headshot3.wav")

	// Sprite Fire = Set Self On Fire When Using Uppercut
	gSpriteFire = precache_model("sprites/kenupc.spr")
}
//----------------------------------------------------------------------------------------------
#if SEND_COOLDOWN
public sendKenCooldown(id)
{
	new cooldown
	if (gPlayerInCooldown[id])
		cooldown = floatround( get_pcvar_num(pCvarCooldown) - get_gametime() + KenUsedTime[id] + 0.4 )
	else
		cooldown = -1
	return cooldown
}
#endif
//----------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode)
{
	if ( gHeroID != heroID ) return

	// Clear out any stale tasks
	remove_task(id)

	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}
//----------------------------------------------------------------------------------------------
public plugin_cfg()
{
	loadCVARS()
}
//----------------------------------------------------------------------------------------------
loadCVARS()
{
	gThrust = get_pcvar_float(pCvarThrust)
	gMaxSpeed = get_pcvar_float(pCvarMaxSpeed)
	gMultiplier = get_pcvar_float(pCvarXyMult)
	gMaxDamage = get_pcvar_num(pCvarMaxDamage) / 2
}
//----------------------------------------------------------------------------------------------
public ken_loop(args[])
{
	new id = args[0]

	if ( !sh_is_active() || !is_user_alive(id) ) return

	static Float:velocity[3]

	pev(id, pev_velocity, velocity)

	// This case execute when ken hits the ground or starts from the ground. 
	if ( pev(id, pev_flags) & FL_ONGROUND) {
		gAirFlag = -1 //you hit the ground, disable midair shoryuken handling
		
		// reset modified_shoryuken variables, except damage
		gThrust = get_pcvar_float(pCvarThrust)
		gMaxSpeed = get_pcvar_float(pCvarMaxSpeed)
		gMultiplier = get_pcvar_float(pCvarXyMult)

		velocity[2] += 100.0 		
		set_pev(id, pev_velocity, velocity)		// Give them a small upward lift
	}

	velocity[0] = velocity[0] * gMultiplier 
	velocity[1] = velocity[1] * gMultiplier	 
	velocity[2] += gThrust 

	if ( velocity[0] > gMaxSpeed )		velocity[0] = gMaxSpeed
	else if ( velocity[0] < (gMaxSpeed * -1.0) )	velocity[0] = gMaxSpeed * -1.0

	if ( velocity[1] > gMaxSpeed )		velocity[1] = gMaxSpeed
	else if ( velocity[1] < (gMaxSpeed * -1.0) )	velocity[1] = gMaxSpeed * -1.0

	//new logic for midair shoryuken handling, 75% the period of the jetpack duration. 
	new fall_cycles = floatround(get_pcvar_float(pCvarDuration) * 10.0 * 0.75)

	if (gAirFlag > fall_cycles) {
		if ( velocity[2] > gThrust * 2.0 )	velocity[2] = gThrust * 2.0 
		gAirFlag = -1
	}	
	else if (gAirFlag > 0) {
		velocity[2] = gThrust * -1.5 	//reverse thrust, half strength.  											
		gAirFlag++
	}
	else {  
		if ( velocity[2] > gThrust * 2.0 )	velocity[2] = gThrust * 2.0 
	}

	// if running full strength
	if ( gJetPackRunning[id] ) {
		set_pev(id, pev_velocity, velocity)
	}
	// when touch event turns jetpack off, kill velocity a bit. 
	else if (!gJetPackRunning[id]) {
		velocity[0] = velocity[0] / 1.1
		velocity[1] = velocity[1] / 1.1
		velocity[2] = gThrust * 1.8

		set_pev(id, pev_velocity, velocity)
	}

}
//----------------------------------------------------------------------------------------------
public sh_hero_key(id, heroID, key)
{
	if ( gHeroID != heroID ) return
	if ( !hasRoundStarted() ) return

	switch(key)
	{
		case SH_KEYDOWN: {
			if ( sh_is_freezetime() || !is_user_alive(id) ) return

			if ( gPlayerInCooldown[id]) {
				sh_sound_deny(id)
				return
			}

			//explode_radius(id) 		//TODO - this is one way we handled ken in a legacy ken version; where on keydown there was immediate radius based hit dection
										// we spent two days recoding the hero to achieve the flavor the new version.
										// this check at this location would require additional logic; do not enable otherwise. 

			//Reload CVARS to make sure the variables are current / reset
			loadCVARS()

			modify_shoryuken(id)

			gAirFlag = 0 //reset flag. 

			//gJetPackRunning[id] = true	//moved to the end of modify shoryuken; the touch event could insta-trigger before gMaxDamage is recalculated. 

			// This needs to change to a forward check
			set_user_info(id, "JP", "1")			

			static Float:veloctmp[3]
			pev(id, pev_velocity, veloctmp)			

			// When your in mid air, set a flag and give a small downward push
			if ( !(pev(id, pev_flags) & FL_ONGROUND) ) {
				veloctmp[2] -= 100.0
				set_pev(id, pev_velocity, veloctmp)
				gAirFlag = 1
			}

			setScreenFlash(id, 219, 112, 147, 1, 60)		

			new Float:duration = get_pcvar_float(pCvarDuration) * 10.0

			// Set Self On Fire and Glow
			new args[1]
			args[0]=id

			set_task(get_pcvar_float(pCvarTimer),"ken_loop",id+1,args,1,"a",floatround(duration)) //id smudged so effect persists past remove_task
			set_task(0.3,"fire_effect",id+1,args,1,"a",7)
			set_task(get_pcvar_float(pCvarDuration),"ken_end",id,args,1,"a",1)

			// Shout "Shoryuken!" Just Like In The Game
			emit_sound(id, CHAN_WEAPON, "shmod/kenshoryuken.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM)			

			sh_set_cooldown(id, get_pcvar_float(pCvarCooldown))

			#if SEND_COOLDOWN
			KenUsedTime[id] = get_gametime()
			#endif
		}

		case SH_KEYUP: {

			//unsure what to do with Keyup event
			//may not need this case. may be able to remove. all the action happens on keydown. 
			//or use this to make it so you can key_up to end the move early.

			// normally gJetPackRunning gets reset on key_up 
			// Ken Masters will reset gJetPackRunning to 0 on ken_end. 
		}
	}
}
//----------------------------------------------------------------------------------------------
public sh_client_death(victim)
{
	gJetPackRunning[victim] = false
	gPlayerInCooldown[victim] = false

	// This needs to change to a forward check
	set_user_info(victim, "JP", "0")

	remove_task(victim)
}
//----------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	gJetPackRunning[id] = false
	gPlayerInCooldown[id] = false
	set_user_info(id, "JP", "0")
	
}
//----------------------------------------------------------------------------------------------
public client_disconnect(id)
{
	// stupid check but lets see
	if ( id < 1 || id > sh_maxplayers() ) return

	gJetPackRunning[id] = false
	gPlayerInCooldown[id] = false

	// This needs to change to a forward check
	set_user_info(id, "JP", "0")

	remove_task(id)
}
//----------------------------------------------------------------------------------------------
public client_connect(id)
{
	// stupid check but lets see
	if ( id < 1 || id > sh_maxplayers() ) return

	gJetPackRunning[id] = false
	gPlayerInCooldown[id] = false

	// This needs to change to a forward check
	set_user_info(id, "JP", "0")

	remove_task(id)
}
//-------------------------------------------------------------------------------------------------------
public fire_effect(args[])
{
	new id = args[0]

	new vec[3]

	get_user_origin(id,vec)

	new iScale = random_num(8,30)

	// Set Self On Fire When Using Uppercut (SPRITE)
	message_begin( MSG_BROADCAST,SVC_TEMPENTITY)
	write_byte(17)
	write_coord(vec[0])
	write_coord(vec[1])
	write_coord(vec[2])
	write_short(gSpriteFire)
	write_byte(iScale)
	write_byte(100)
	message_end()

}
//-------------------------------------------------------------------------------------------------------
public ken_end(args[])
{
	new id = args[0]

	if (gJetPackRunning[id]) {
		explode_radius(id)
		//set_task(0.4, "explode_radius", id+1, args, 1)		//Would add a small delay, maybe desirable. 
	}	

	gJetPackRunning[id] = false
	
	set_user_info(id, "JP", "0")
	remove_task(id)
}	
//-------------------------------------------------------------------------------------------------------
//
//touch event
//
#if defined AMX_NEW
public entity_touch(entity1, entity2) {
	new pToucher = entity1
	new pTouched = entity2
#else
public vexd_pfntouch(pToucher, pTouched) {
#endif


	if ( !is_user_alive(pToucher) || !is_user_alive(pTouched) ) return

	if ( gJetPackRunning[pTouched] ) {

		new FFOn = sh_friendlyfire_on()
		new CsTeams:idTeam = cs_get_user_team(pTouched)

		if ( FFOn || idTeam != cs_get_user_team(pToucher) ) {
			
			new parm[3]
			parm[0] = pTouched
			parm[1] = pToucher
			parm[2] = gMaxDamage
			set_task(0.1, "uppercut", pTouched+1, parm, 3)

			gJetPackRunning[pTouched] = false

			new name[32]
			get_user_name(pToucher, name, charsmax(name))
			sh_chat_message(pTouched, gHeroID, "You have struck %s with Shoryuken directly for %d damage", name, parm[2])
			get_user_name(pTouched, name, charsmax(name))
			sh_chat_message(pToucher, gHeroID, "%s has struck you directly with Shoryuken for %d damage", name, parm[2])	

		}
	}
}
//-------------------------------------------------------------------------------------------------------
public uppercut(parm[])
{
	new id = parm[0]
	new vic = parm[1]
	new dmg = parm[2]
	new Origin[3], vicOrigin[3]
	new Float:vicheight = get_cvar_float("ken_vicheight")

	get_user_origin(id, Origin)
	get_user_origin(vic, vicOrigin)

	//sound on hit. 
	emit_sound(vic, CHAN_BODY, "player/headshot3.wav", 1.0, ATTN_NORM, 0, PITCH_LOW)

	new Float:fl_Time = get_distance(vicOrigin, Origin) / 150.0
	
	new Float:fl_vicVelocity[3]
	fl_vicVelocity[0] = (vicOrigin[0] - Origin[0]) / fl_Time //* dmg / gMaxDamage //commented out, killed off movement too much
	fl_vicVelocity[1] = (vicOrigin[1] - Origin[1]) / fl_Time //* dmg / gMaxDamage
	if (dmg < gMaxDamage) {
		fl_vicVelocity[2] = vicheight * dmg / gMaxDamage

		//minimum of 75% effective
		if (fl_vicVelocity[2] < vicheight * 0.75) fl_vicVelocity[2] = vicheight * 0.75
	}
	else fl_vicVelocity[2] = vicheight

	set_pev(vic, pev_velocity, fl_vicVelocity)
		
	shExtraDamage(vic, id, dmg, "Shoryuken")
	//sh_extra_damage(vic, id, dmg, "Shoryuken", _, SH_DMG_NORM, true, _, Origin) //new damage statement; affected by armor -50% dmg. 

	new args[1]
	args[0]=vic

	set_task(0.3,"fire_effect",vic,args,1,"a",7)

	new argsid[1]
	argsid[0]=id

	ken_end(argsid)
}
//-------------------------------------------------------------------------------------------------------
public explode_radius(id)
{
	new Float:dRatio, damage, Float:distanceBetween
	new Float:dmgRadius = get_pcvar_float(pCvarRadius)
	new bool:FFOn = sh_friendlyfire_on()
	new CsTeams:idTeam = cs_get_user_team(id)
	
	new players[SH_MAXSLOTS], playerCount, player
	new Float:playerOrigin[3]
	new Float:kenOrigin[3] 

	pev(id, pev_origin, kenOrigin)

	get_players(players, playerCount, "ah")

	for ( new i = 0; i < playerCount; i++ ) {
		player = players[i]
		pev(player, pev_origin, playerOrigin)
		distanceBetween = vector_distance(kenOrigin, playerOrigin)

		if ( distanceBetween <= dmgRadius ) {
			if ( FFOn || player != id && idTeam != cs_get_user_team(player) ) {
				dRatio = distanceBetween / dmgRadius
				damage = gMaxDamage - floatround(gMaxDamage * dRatio)
				if ( !damage ) damage = get_pcvar_num(pCvarMaxDamage) / 2	// Incase damage cvar is really low cause something if within the radius 
				
				new parm[3]
				parm[0] = id
				parm[1] = player
				parm[2] = damage
				set_task(0.3, "uppercut", id+1, parm, 3)

				new name[32]
				get_user_name(player, name, charsmax(name))
				sh_chat_message(id, gHeroID, "Your Shoryuken ends in a blast, striking %s for %d damage", name, damage)
				get_user_name(id, name, charsmax(name))
				sh_chat_message(player, gHeroID, "%s has struck you with a glancing Shoryuken for %d damage", name, damage)

			}
			// Add some push and shake effects instead of dmgStun later, and cause it on everyone within radius
		}
	}	
}
//-------------------------------------------------------------------------------------------------------
public modify_shoryuken(id)
{	
	new height = floatround(distance_to_ground(id))

	//modify shoryuken based on z-height (vec[2])
	switch(height)
	{
		//case 1..99: {
		//	gMultiplier += 0.01
		//	gMaxDamage = floatround( get_pcvar_num(pCvarMaxDamage) * 0.6 )
		//	sh_chat_message(id, gHeroID, "Case 0 ground trigger: %d", height)
		//	}
		case 100..299: {
			gThrust = gThrust * 1.3
			gMaxSpeed = gMaxSpeed * 1.3
			gMultiplier += 0.03
			gMaxDamage = floatround( get_pcvar_num(pCvarMaxDamage) * 0.7 )
			//sh_chat_message(id, gHeroID, "Case 1 trigger: %d", height)
		}
		case 300..399: {
			gThrust = gThrust * 1.6
			gMaxSpeed = gMaxSpeed * 1.4
			gMultiplier += 0.04
			gMaxDamage = floatround( get_pcvar_num(pCvarMaxDamage) * 0.8 )
			//sh_chat_message(id, gHeroID, "Case 2 trigger: %d", height)
		}
		case 400..499: {
			gThrust = gThrust * 1.9
			gMaxSpeed = gMaxSpeed * 1.5
			gMultiplier += 0.05
			gMaxDamage = floatround( get_pcvar_num(pCvarMaxDamage) * 0.9 )
			//sh_chat_message(id, gHeroID, "Case 3 trigger: %d", height)
		}
		case 500..9999: {
			gThrust = gThrust * 2.0
			gMaxSpeed = gMaxSpeed * 1.6
			gMultiplier += 0.06
			gMaxDamage = get_pcvar_num(pCvarMaxDamage)
			//sh_chat_message(id, gHeroID, "Case 4 trigger: %d", height)
		}		
		default: {
			gMultiplier += 0.01
			//sh_chat_message(id, gHeroID, "Case Default: %d", height)		
		}
	}

	gJetPackRunning[id] = true
}
//-------------------------------------------------------------------------------------------------------
Float:distance_to_ground( id )  { 
    new Float:start[3], Float:end[3], bool:bDucking; 
    entity_get_vector(id, EV_VEC_origin, start); 
    bDucking = (entity_get_int(id, EV_INT_flags) & FL_DUCKING) ? true : false; 

    end[0] = start[0]; 
    end[1] = start[1]; 
    end[2] = start[2] - 9999.0; 

    new ptr = create_tr2(); 
    engfunc(EngFunc_TraceHull, start, end, IGNORE_MONSTERS, (bDucking) ? HULL_HEAD : HULL_HUMAN, id, ptr); 
    new Float:distance; 
    get_tr2(ptr, TR_flFraction, distance); 
    free_tr2(ptr); 

    if( distance < 1.0 ) { 
        distance *= 9999.0; 
    } 

    //sh_chat_message(id, gHeroID, "Distance calc - %d", floatround(distance))
    return distance
}