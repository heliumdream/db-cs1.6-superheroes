// SECRETARY OF DEFENSE!

/* CVARS - copy and paste to shconfig.cfg

//Secretary of Defense
secretary_level 0
secretary_radius 2000		//Radius of people affected by blast
secretary_maxdamage 1000	//Maximum damage to deal to a player
secretary_cooldown 60		//# of seconds before you can install another beacon
secretary_delay 35		//# of seconds between setup and start of rotation
secretary_burndecals 1		//Show the burn decals on the ground
secretary_workinside 0		//Allow Ion Cannon to work inside buidings and so on

*/

/*
* v1.1 - Fr33m@n - 5/8/12
*      - Added the ability to change the delay between setup and start of rotation
*
* v1.0 - Fr33m@n - 5/7/12
*      - Original release.
*
*   Based on Weapon Mod weapon : Ion Cannon (C&C Renegade: Reborn) v1.92.
*   By A.F. aka hjkwe654.
*/


// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1

#include <superheromod>
#include <engine>

#define XO_WEAPON 4
#define m_flNextPrimaryAttack 46
#define m_flNextSecondaryAttack 47

// Sequences
enum {
	anim_idle,
	anim_draw,
	anim_holset,
	anim_use
}

// GLOBAL VARIABLES
new gHeroID
new const gHeroName[] = "Secretary of Defense"
new bool:gHasSecretary[SH_MAXSLOTS+1]
new bool:gHasRadio[SH_MAXSLOTS+1]
new gLastModelKnife[SH_MAXSLOTS+1][64]
new g_Target[SH_MAXSLOTS+1]
new i_Pitch[SH_MAXSLOTS+1]
new Float:i_BeaconTime[SH_MAXSLOTS+1]
new bool:gIsCharging[SH_MAXSLOTS+1]
new Float:ion_mid_origin[SH_MAXSLOTS+1][3]
new Float:beam_origin[SH_MAXSLOTS+1][8][3]
new Float:g_degrees[SH_MAXSLOTS+1][8]
new Float:g_distance[SH_MAXSLOTS+1]
new Float:g_Speed[SH_MAXSLOTS+1]

new const gModelKnife[] = "models/shmod/ion_v_radio.mdl"
new const gModelBeacon[] = "models/w_battery.mdl"
new const gSoundRadioDraw[] = "shmod/ion/radio_draw.wav"
new const gSoundRadioUse[] = "shmod/ion/radio_use.wav"
new const gSoundBeacon[] = "shmod/ion/beacon_set.wav"
new const gSoundPlant[] = "shmod/ion/beacon_plant.wav"
new const gSoundBeep[] = "shmod/ion/beacon_beep.wav"
new const gSoundApproach[] = "shmod/ion/approaching.wav"
new const gSoundReady[] = "shmod/ion/ready.wav"
new const gSoundAttack[] = "shmod/ion/attack.wav"
new gSpriteIonBeam, gSpriteBlueFire, gSpriteShockwave, gSpriteReadyFire, gSpriteBlueFlare, gSpriteLaserFlame
new gBigShotDecal, gScorchDecal
new gPcvarRadius, gPcvarMaxDamage, gPcvarCooldown, gPcvarBurnDecals, gPcvarWorkInside, gPcvarDelay
new gmsgBarTime, gmsgScreenShake

#if SEND_COOLDOWN
new Float:SecretaryUsedTime[SH_MAXSLOTS+1]
#endif
//----------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Secretary of Defense", "1.1", "A.F./Fr33m@n")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel = register_cvar("secretary_level", "0")
	gPcvarRadius = register_cvar("secretary_radius", "2000")
	gPcvarMaxDamage = register_cvar("secretary_maxdamage", "1000")
	gPcvarCooldown = register_cvar("secretary_cooldown", "60")
	gPcvarDelay = register_cvar("secretary_delay", "35")
	gPcvarBurnDecals = register_cvar("secretary_burndecals", "1")
	gPcvarWorkInside = register_cvar("secretary_workinside", "0")

	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel)
	sh_set_hero_info(gHeroID, "Ion Cannon", "Call the Secretary of Defense to fire a beacon with the Ion Cannon Satellite")
	sh_set_hero_bind(gHeroID)

	// REGISTER EVENTS THIS HERO WILL RESPOND TO!
	register_event("CurWeapon", "weapon_change", "be", "1=1")
	register_forward(FM_CmdStart, "FM_CmdStart_Pre", false)
	register_forward(FM_EmitSound, "FM_EmitSound_Pre", false)

	// Set to correct decals if mod is CZ or CS
	gBigShotDecal = engfunc(EngFunc_DecalIndex, "{bigshot5")
	gScorchDecal = engfunc(EngFunc_DecalIndex, "{scorch3")

	gmsgBarTime = get_user_msgid("BarTime")
	gmsgScreenShake = get_user_msgid("ScreenShake")
}
//----------------------------------------------------------------------------------------------
public plugin_precache()
{
	precache_model(gModelKnife)
	precache_model(gModelBeacon)
	precache_sound(gSoundRadioDraw)
	precache_sound(gSoundRadioUse)
	precache_sound(gSoundBeacon)
	precache_sound(gSoundPlant)
	precache_sound(gSoundBeep)
	precache_sound(gSoundApproach)
	precache_sound(gSoundReady)
	precache_sound(gSoundAttack)
	gSpriteIonBeam = precache_model("sprites/shmod/ion/ionbeam.spr")
	gSpriteBlueFlare = precache_model("sprites/shmod/ion/bflare.spr")
	gSpriteReadyFire = precache_model("sprites/shmod/ion/fire.spr")
	gSpriteBlueFire = precache_model("sprites/shmod/ion/blueflame.spr")
	gSpriteLaserFlame = precache_model("sprites/shmod/ion/ion_laserflame.spr")
	gSpriteShockwave = precache_model("sprites/shockwave.spr")
}
//----------------------------------------------------------------------------------------------
#if SEND_COOLDOWN
public sendSecretaryCooldown(id)
{
	new cooldown
	if (gPlayerInCooldown[id])
		cooldown = floatround( get_pcvar_num(gPcvarCooldown) - get_gametime() + SecretaryUsedTime[id] + 0.4 )
	else
		cooldown = -1
	return cooldown
}
#endif
//----------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode)
{
	if ( gHeroID != heroID ) return

	if ( mode ) {
		gHasSecretary[id] = true
	}
	else {
		gHasSecretary[id] = false
		if ( gHasRadio[id] ) {
			new iKnifeEnt = find_ent_by_owner(-1, "weapon_knife", id)
			if ( iKnifeEnt > 0 ) {
				set_pdata_float(iKnifeEnt, m_flNextPrimaryAttack, -1.0, XO_WEAPON)
				set_pdata_float(iKnifeEnt, m_flNextSecondaryAttack, -0.001, XO_WEAPON)

				if ( get_user_weapon(id) == CSW_KNIFE ) {
					ExecuteHamB(Ham_Item_Deploy, iKnifeEnt)
					set_pev(id, pev_viewmodel2, gLastModelKnife[id])
				}
			}
			gHasRadio[id] = false
		}
	}

	if ( g_Target[id] > 0 ) {
		remove_target(id)
	}
	if ( gIsCharging[id] ) {
		stop_charging(id)
	}

	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}
//----------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	if ( gHasRadio[id] ) {
		new iKnifeEnt = find_ent_by_owner(-1, "weapon_knife", id)
		if ( iKnifeEnt > 0 ) {
			set_pdata_float(iKnifeEnt, m_flNextPrimaryAttack, -1.0, XO_WEAPON)
			set_pdata_float(iKnifeEnt, m_flNextSecondaryAttack, -0.001, XO_WEAPON)
		}
		gHasRadio[id] = false
	}
	gIsCharging[id] = false
	gPlayerInCooldown[id] = false
}
//----------------------------------------------------------------------------------------------
public sh_round_end()
{
	new players[32], playerCount, player
	get_players(players, playerCount, "h")

	for ( new i = 0; i < playerCount; i++ ) {
		player = players[i]

		if ( g_Target[player] > 0 ) {
			remove_target(player)
		}
		if ( gIsCharging[player] ) {
			stop_charging(player)
		}
	}
}
//----------------------------------------------------------------------------------------------
public client_disconnect(id)
{
	if ( g_Target[id] > 0 ) {
		remove_target(id)
	}
	if ( gIsCharging[id] ) {
		stop_charging(id)
	}
}
//----------------------------------------------------------------------------------------------
public sh_client_death(victim)
{
	if ( victim < 1 || victim > sh_maxplayers() ) return

	if ( gIsCharging[victim] ) {
		stop_charging(victim)
	}
}
//----------------------------------------------------------------------------------------------
public sh_hero_key(id, heroID, key)
{
	if ( gHeroID != heroID ) return
	if ( !sh_is_inround() || !is_user_alive(id) ) return

	if ( key == SH_KEYDOWN ) {
		new iKnifeEnt = find_ent_by_owner(-1, "weapon_knife", id)
		if ( iKnifeEnt > 0 ) {
			if ( gHasRadio[id] ) {
				gHasRadio[id] = false
				client_print(id, print_center, "[SH]%s: Radio disabled, Knife enabled.", gHeroName)

				set_pdata_float(iKnifeEnt, m_flNextPrimaryAttack, -1.0, XO_WEAPON)
				set_pdata_float(iKnifeEnt, m_flNextSecondaryAttack, -0.001, XO_WEAPON)

				if ( get_user_weapon(id) == CSW_KNIFE ) {
					ExecuteHamB(Ham_Item_Deploy, iKnifeEnt)
					set_pev(id, pev_viewmodel2, gLastModelKnife[id])
				}
			}
			else {
				gHasRadio[id] = true
				client_print(id, print_center, "[SH]%s: Radio enabled, Knife disabled.", gHeroName)

				set_pdata_float(iKnifeEnt, m_flNextPrimaryAttack, 99999.0, XO_WEAPON)
				set_pdata_float(iKnifeEnt, m_flNextSecondaryAttack, 99999.0, XO_WEAPON)

				if ( get_user_weapon(id) == CSW_KNIFE ) {
					set_pev(id, pev_viewmodel2, gModelKnife)
					emit_sound(id, CHAN_WEAPON, gSoundRadioDraw, VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
					send_weapon_anim(id, anim_draw)
				}
				else {
					// Switch to knife
					engclient_cmd(id, "weapon_knife")
				}
			}
		}
	}
}
//----------------------------------------------------------------------------------------------
public weapon_change(id)
{
	if ( !sh_is_active() ) return
	if ( !is_user_alive(id) || !gHasSecretary[id] || !gHasRadio[id] ) return

	if ( gIsCharging[id] ) {
		stop_charging(id)
	}

	if ( read_data(2) != CSW_KNIFE ) return

	pev(id, pev_viewmodel2, gLastModelKnife[id], 63)
	set_pev(id, pev_viewmodel2, gModelKnife)
	send_weapon_anim(id, anim_draw)
}
//----------------------------------------------------------------------------------------------
public FM_CmdStart_Pre(id, uc_handle, seed)
{
	if ( !sh_is_active() ) return FMRES_IGNORED
	if ( !sh_is_inround() || !is_user_alive(id) || !gHasSecretary[id] || !gHasRadio[id] ) return FMRES_IGNORED

	if ( get_user_weapon(id) != CSW_KNIFE ) return FMRES_IGNORED

	static buttons, oldbuttons
	buttons = get_uc(uc_handle, UC_Buttons)
	oldbuttons = pev(id, pev_oldbuttons)

	set_uc( uc_handle, UC_Buttons, buttons & ~(IN_ATTACK | IN_ATTACK2) )

	//Check speed of player against the checkmove cvar
	new Float:velocity[3]
	pev(id, pev_velocity, velocity)

	if ( vector_length(velocity) >= 2.0 || !(pev(id, pev_flags) & FL_ONGROUND) ) {
		if ( gIsCharging[id] ) {
			sh_chat_message(id, gHeroID, "Don't move when you setup the beacon")
			stop_charging(id)
		}
		return FMRES_HANDLED
	}

	if ( buttons & IN_ATTACK ) {
		if ( !(oldbuttons & IN_ATTACK) ) {
			send_weapon_anim(id, anim_use)
			emit_sound(id, CHAN_WEAPON, gSoundRadioUse, VOL_NORM, ATTN_NORM, 0, PITCH_NORM)

			if ( g_Target[id] ) {
				sh_chat_message(id, gHeroID, "You already planted a beacon")
				return FMRES_HANDLED
			}

			if ( gPlayerInCooldown[id] ) {
				sh_chat_message(id, gHeroID, "Ion cannon is recharging, you must wait longer")
				return FMRES_HANDLED
			}

			new Float:fl_Origin[3], Float:fl_TraceEnd[3], Float:fl_EndPos[3]
			pev(id, pev_origin, fl_Origin)

			fl_TraceEnd[0] = fl_Origin[0]
			fl_TraceEnd[1] = fl_Origin[1]
			fl_TraceEnd[2] = fl_Origin[2] + 9999.0

			new ptr = create_tr2()
			engfunc(EngFunc_TraceLine, fl_Origin, fl_TraceEnd, IGNORE_MONSTERS + IGNORE_GLASS, id, ptr)
			get_tr2(ptr, TR_vecEndPos, fl_EndPos)
			free_tr2(ptr)

			if ( !get_pcvar_num(gPcvarWorkInside) && engfunc(EngFunc_PointContents, fl_EndPos) != CONTENTS_SKY ) {
				sh_chat_message(id, gHeroID, "You need to be outside to fire with an ion cannon")
				return FMRES_HANDLED
			}
			emit_sound(id, CHAN_STATIC, gSoundBeacon, VOL_NORM, ATTN_NORM, 0, PITCH_NORM)

			g_Target[id] = 0
			i_Pitch[id] = 97
			i_BeaconTime[id] = 1.12
			g_distance[id] = 350.0
			g_Speed[id] = 0.0

			gIsCharging[id] = true

			progressBar(id, 5)
			set_task(5.0, "ion_planted", 5000+id)
		}
	}
	else if ( oldbuttons & IN_ATTACK && gIsCharging[id] ) {
		stop_charging(id)
	}

	return FMRES_HANDLED
}
//----------------------------------------------------------------------------------------------
public ion_planted(id)
{
	if ( !sh_is_inround() ) return

	id -= 5000

	sh_chat_message(0, gHeroID, "Ion cannon beacon deploy")
	client_cmd(0, "spk %s", gSoundPlant)

	gIsCharging[id] = false

	new TargetEnt = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"))
	if ( !TargetEnt ) {
		sh_chat_message(id, gHeroID, "Ion Cannon Beacon Creation Failure")
		return
	}

	g_Target[id] = TargetEnt

	// Strings
	set_pev(TargetEnt, pev_classname, "info_target_ion")
	engfunc(EngFunc_SetModel, TargetEnt, gModelBeacon)

	// Integer
	set_pev(TargetEnt, pev_owner, id)
	set_pev(TargetEnt, pev_movetype, MOVETYPE_TOSS)
	set_pev(TargetEnt, pev_solid, SOLID_TRIGGER)

	new Float:fl_Origin[3]
	pev(id, pev_origin, fl_Origin)
	fl_Origin[2] += 6.0

	engfunc(EngFunc_SetOrigin, TargetEnt, fl_Origin)

	ion_beacon(id)
	set_task(5.0, "ion_startup", id)

	new Float:i_Delay = get_pcvar_float(gPcvarDelay)
	if ( i_Delay < 0.1 ) {
		i_Delay = 0.1
	}
	set_task(i_Delay, "Trace_Ready", id)
}
//----------------------------------------------------------------------------------------------
public ion_beacon(id)
{
	if ( !g_Target[id] || !sh_is_inround() ) return		

	new Float:iDelay = get_pcvar_float(gPcvarDelay)
	if ( iDelay < 0.1 ) {
		iDelay = 0.1
	}
	new iCalculatedPitch = floatround(floatclamp((3*50.2)/(iDelay+15.2), 1.00000, 99999.0))
	i_Pitch[id] += iCalculatedPitch			// default: 3
	new Float:iCalculatedBeaconTime = floatclamp((0.03*50.2)/(iDelay+15.2), 0.00001, 99999.0)
	i_BeaconTime[id] -= iCalculatedBeaconTime		// default: 0.03
	if ( i_Pitch[id] > 255 ) {
		i_Pitch[id] = 255
	}
	if ( i_BeaconTime[id] < 0.30 ) {
		i_BeaconTime[id] = 0.30
	}
	emit_sound(g_Target[id], CHAN_ITEM, gSoundBeep, VOL_NORM, ATTN_NORM, 0, i_Pitch[id])
	set_task(i_BeaconTime[id], "ion_beacon", id)
}
//----------------------------------------------------------------------------------------------
public ion_startup(id)
{
	if ( !g_Target[id] || !sh_is_inround() ) return

	client_cmd(0, "spk ^"%s^"", gSoundApproach)
	sh_chat_message(0, gHeroID, "Warning - Ion cannon satelite approaching")
}
//----------------------------------------------------------------------------------------------
public Trace_Ready(id)
{
	if ( !g_Target[id] || !sh_is_inround() ) return

	// write origin of each
	new Float:mid_origin[SH_MAXSLOTS+1][3]
	pev(g_Target[id], pev_origin, mid_origin[id]) // Target contain entity id
	// 1st
	beam_origin[id][0][0] = mid_origin[id][0] + 300.0
	beam_origin[id][0][1] = mid_origin[id][1] + 150.0
	beam_origin[id][0][2] = mid_origin[id][2]
	g_degrees[id][0] = 0.0
	// 2nd
	beam_origin[id][1][0] = mid_origin[id][0] + 300.0
	beam_origin[id][1][1] = mid_origin[id][1] - 150.0
	beam_origin[id][1][2] = mid_origin[id][2]
	g_degrees[id][1] = 45.0
	// 3rd
	beam_origin[id][2][0] = mid_origin[id][0] - 300.0
	beam_origin[id][2][1] = mid_origin[id][1] - 150.0
	beam_origin[id][2][2] = mid_origin[id][2]
	g_degrees[id][2] = 90.0
	// 4th
	beam_origin[id][3][0] = mid_origin[id][0] - 300.0
	beam_origin[id][3][1] = mid_origin[id][1] + 150.0
	beam_origin[id][3][2] = mid_origin[id][2]
	g_degrees[id][3] = 135.0
	// 5th
	beam_origin[id][4][0] = mid_origin[id][0] + 150.0
	beam_origin[id][4][1] = mid_origin[id][1] + 300.0
	beam_origin[id][4][2] = mid_origin[id][2]
	g_degrees[id][4] = 180.0
	// 6th
	beam_origin[id][5][0] = mid_origin[id][0] + 150.0
	beam_origin[id][5][1] = mid_origin[id][1] - 300.0
	beam_origin[id][5][2] = mid_origin[id][2]
	g_degrees[id][5] = 225.0
	// 7th
	beam_origin[id][6][0] = mid_origin[id][0] - 150.0
	beam_origin[id][6][1] = mid_origin[id][1] - 300.0
	beam_origin[id][6][2] = mid_origin[id][2]
	g_degrees[id][6] = 270.0
	// 8th
	beam_origin[id][7][0] = mid_origin[id][0] - 150.0
	beam_origin[id][7][1] = mid_origin[id][1] + 300.0
	beam_origin[id][7][2] = mid_origin[id][2]
	g_degrees[id][7] = 315.0

	// set the mid to global
	ion_mid_origin[id] = mid_origin[id]

	new Float:addtime
	for ( new i = 0; i < 8; i++ ) {
		addtime = addtime + 0.3
		new param[3]
		param[0] = i
		param[1] = id
		set_task(0.0 + addtime, "Trace_Start", _,param, 2)
	}

	Laser_Rotate(id) //To fix the laserdraw
	client_cmd(0, "spk ^"%s^"", gSoundReady)

	for ( new Float:i = 0.0; i < 7.5; i += 0.01 ) {	//Rotate for 7.5 secs
		set_task(i+3.0, "Laser_Rotate", id)
	}

	set_task(2.9, "AddSpeed", id)
	set_task(11.5, "CreateFire", id)
	set_task(12.5, "ClearLasers", id)
	set_task(15.2, "FireIonCannon", id)
}
//----------------------------------------------------------------------------------------------
public AddSpeed(id)
{
	if ( !g_Target[id] || !sh_is_inround() ) return

	if ( g_Speed[id] > 1.0 ) {
		g_Speed[id] = 1.0
	}
	g_Speed[id] += 0.1
	set_task(0.6, "AddSpeed", id)
}
//----------------------------------------------------------------------------------------------
public CreateFire(id)
{
	if ( !g_Target[id] || !sh_is_inround() ) return

	// Additive sprite, plays 1 cycle
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, ion_mid_origin[id], 0)
	write_byte(TE_SPRITE)			// 17
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][0])			// position.x
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][1])			// position.y
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][2] + 100)	// position.z
	write_short(gSpriteReadyFire)	// sprite index
	write_byte(30)					// scale in 0.1's
	write_byte(200)					// brightness
	message_end()

	set_task(1.5, "CreateFire", id)
}
//----------------------------------------------------------------------------------------------
public ClearLasers(id)
{
	remove_task(1018+id)
}
//----------------------------------------------------------------------------------------------
public Laser_Rotate(id)
{
	if ( !g_Target[id] || !sh_is_inround() ) return

	g_distance[id] -= 0.467
	for ( new i = 0; i < 8; i++ ) {
		// Calculate new alpha
		g_degrees[id][i] += g_Speed[id]
		if ( g_degrees[id][i] > 360.0 ) {
			g_degrees[id][i] -= 360.0
		}

		// calcul the next origin
		new Float:tmp[SH_MAXSLOTS+1][3]
		tmp[id] = ion_mid_origin[id]

		tmp[id][0] += floatsin(g_degrees[id][i], degrees) * g_distance[id]
		tmp[id][1] += floatcos(g_degrees[id][i], degrees) * g_distance[id]
		tmp[id][2] += 0.0 // -.-
		beam_origin[id][i] = tmp[id]
	}
}
//----------------------------------------------------------------------------------------------
public Trace_Start(param[])
{
	new i = param[0]
	new id = param[1]

	if ( !g_Target[id] || !sh_is_inround() ) return

	new Float:get_random_z, Float:SkyOrigin[SH_MAXSLOTS+1][3]
	SkyOrigin[id] = tlx_distance_to_sky(g_Target[id])
	get_random_z = random_float(300.0, SkyOrigin[id][2])

	// Additive sprite, plays 1 cycle
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, beam_origin[id][i], 0)
	write_byte(TE_SPRITE)			// 17
	engfunc(EngFunc_WriteCoord, beam_origin[id][i][0])					// position.x
	engfunc(EngFunc_WriteCoord, beam_origin[id][i][1])					// position.y
	engfunc(EngFunc_WriteCoord, beam_origin[id][i][2] + get_random_z)	// position.z
	write_short(gSpriteBlueFire)	// sprite index
	write_byte(10)					// scale in 0.1's
	write_byte(100)					// brightness
	message_end()

	TraceAll(param)
}
//----------------------------------------------------------------------------------------------
public TraceAll(param[])
{
	new i = param[0]
	new id = param[1]

	if ( !g_Target[id] || !sh_is_inround() ) return

	new Float:SkyOrigin[SH_MAXSLOTS+1][3]
	SkyOrigin[id] = tlx_distance_to_sky(g_Target[id])

	// Beam effect between two points
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, beam_origin[id][i], 0)
	write_byte(TE_BEAMPOINTS)	// 0
	engfunc(EngFunc_WriteCoord, beam_origin[id][i][0])		// startposition.x
	engfunc(EngFunc_WriteCoord, beam_origin[id][i][1])		// startposition.y
	engfunc(EngFunc_WriteCoord, SkyOrigin[id][2])			// startposition.z
	engfunc(EngFunc_WriteCoord, beam_origin[id][i][0])		// endposition.x
	engfunc(EngFunc_WriteCoord, beam_origin[id][i][1])		// endposition.y
	engfunc(EngFunc_WriteCoord, beam_origin[id][i][2])		// endposition.z
	write_short(gSpriteIonBeam)	// sprite index
	write_byte(0)				// starting frame
	write_byte(0)				// frame rate in 0.1's
	write_byte(1)				// life in 0.1's
	write_byte(50)				// line width in 0.1's
	write_byte(0)				// noise amplitude in 0.01's
	write_byte(255)				// red
	write_byte(255)				// green
	write_byte(255)				// blue
	write_byte(255)				// brightness
	write_byte(0)				// scroll speed in 0.1's
	message_end()

	// Additive sprite, plays 1 cycle
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, beam_origin[id][i], 0)
	write_byte(TE_SPRITE)			// 17
	engfunc(EngFunc_WriteCoord, beam_origin[id][i][0])		// position.x
	engfunc(EngFunc_WriteCoord, beam_origin[id][i][1])		// position.y
	engfunc(EngFunc_WriteCoord, beam_origin[id][i][2])		// position.z
	write_short(gSpriteLaserFlame)	// sprite index
	write_byte(5)					// scale in 0.1's
	write_byte(200)					// brightness
	message_end()

	if ( get_pcvar_num(gPcvarBurnDecals) ) {
		// Decal applied to the world brush
		engfunc(EngFunc_MessageBegin, MSG_BROADCAST, SVC_TEMPENTITY, beam_origin[id][i], 0)
		write_byte(TE_WORLDDECAL)				// 116
		engfunc(EngFunc_WriteCoord, beam_origin[id][i][0])	// decal position (center of texture in world)
		engfunc(EngFunc_WriteCoord, beam_origin[id][i][1])
		engfunc(EngFunc_WriteCoord, beam_origin[id][i][2])
		write_byte(gBigShotDecal + random(5))	// decal
		message_end()
	}

	set_task(0.08,"TraceAll", 1018+id, param, 2)
}
//----------------------------------------------------------------------------------------------
public FireIonCannon(id)
{
	if ( !g_Target[id]  || !sh_is_inround() ) return

	new Float:skyOrigin[SH_MAXSLOTS+1][3]
	skyOrigin[id] = tlx_distance_to_sky(g_Target[id])
	new Float:dmgRadius = get_pcvar_float(gPcvarRadius)

	//Break the breakables
	new ent = -1, classname[32]
	while ( (ent = engfunc(EngFunc_FindEntityInSphere, ent, ion_mid_origin[id], dmgRadius)) != 0 )
	{
		// We've found an entity, make sure it's valid and not a player/monster
		if ( !pev_valid(ent) ) continue
		if ( (pev(ent, pev_flags) & (FL_CLIENT | FL_FAKECLIENT | FL_MONSTER)) ) continue

		pev(ent, pev_classname, classname, charsmax(classname))
		if ( equali(classname, "func_breakable") ) {
			dllfunc(DLLFunc_Use, ent, g_Target[id])
			continue
		}
	}

	// Beam effect between two points
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, ion_mid_origin[id], 0)
	write_byte(TE_BEAMPOINTS)	// 0
	engfunc(EngFunc_WriteCoord, skyOrigin[id][0])			// startposition.x
	engfunc(EngFunc_WriteCoord, skyOrigin[id][1])			// startposition.y
	engfunc(EngFunc_WriteCoord, skyOrigin[id][2])			// startposition.z
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][0])		// endposition.x
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][1])		// endposition.y
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][2])		// endposition.z
	write_short(gSpriteIonBeam)	// sprite index
	write_byte(0)				// starting frame
	write_byte(0)				// frame rate in 0.1's
	write_byte(15)				// life in 0.1's
	write_byte(255)				// line width in 0.1's
	write_byte(0)				// noise amplitude in 0.01's
	write_byte(255)				// red
	write_byte(255)				// green
	write_byte(255)				// blue
	write_byte(255)				// brightness
	write_byte(0)				// scroll speed in 0.1's
	message_end()

	// Cylinder that expands to max radius over lifetime
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, ion_mid_origin, 0)
	write_byte(TE_BEAMCYLINDER)		// 21
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][0])					// position.x
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][1])					// position.y
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][2])					// position.z
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][0])					// axis.x
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][1])					// axis.y
	engfunc(EngFunc_WriteCoord, ion_mid_origin[id][2] + (dmgRadius/2))	// axis.z
	write_short(gSpriteShockwave)	// sprite index
	write_byte(0)					// starting frame
	write_byte(0)					// frame rate in 0.1's
	write_byte(100)					// life in 0.1's
	write_byte(150)					// line width in 0.1's
	write_byte(0)					// noise amplitude in 0.01's
	write_byte(0)					// red
	write_byte(100)					// green
	write_byte(250)					// blue
	write_byte(150)					// brightness
	write_byte(0)					// scroll speed in 0.1's
	message_end()

	for ( new i = 1; i < 6; i++ ) {
		// Line of moving glow sprites with gravity, fadeout, and collisions
		engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, ion_mid_origin[id], 0)
		write_byte(TE_SPRITETRAIL)		// 15
		engfunc(EngFunc_WriteCoord, ion_mid_origin[id][0])			// startposition.x
		engfunc(EngFunc_WriteCoord, ion_mid_origin[id][1])			// startposition.y
		engfunc(EngFunc_WriteCoord, ion_mid_origin[id][2])			// startposition.z
		engfunc(EngFunc_WriteCoord, ion_mid_origin[id][0])			// endposition.x
		engfunc(EngFunc_WriteCoord, ion_mid_origin[id][1])			// endposition.y
		engfunc(EngFunc_WriteCoord, ion_mid_origin[id][2] + 200)	// endposition.z
		write_short(gSpriteBlueFlare)	// sprite index
		write_byte(50)					// count
		write_byte(random_num(27, 30))	// life in 0.1's
		write_byte(10)					// scale in 0.1's
		write_byte(random_num(30, 70))	// velocity along vector in 10's
		write_byte(40)					// randomness of velocity in 10's
		message_end()
	}

	if ( get_pcvar_num(gPcvarBurnDecals) ) {
		// Decal and ricochet sound
		engfunc(EngFunc_MessageBegin, MSG_BROADCAST, SVC_TEMPENTITY, ion_mid_origin[id], 0)
		write_byte(TE_GUNSHOTDECAL)					// 109
		engfunc(EngFunc_WriteCoord, ion_mid_origin[id][0])	// decal position (center of texture in world)
		engfunc(EngFunc_WriteCoord, ion_mid_origin[id][1])
		engfunc(EngFunc_WriteCoord, ion_mid_origin[id][2])
		write_short(0)								// entity index???
		write_byte(gScorchDecal + random(3))		// decal
		message_end()
	}

	new Float:dRatio, Float:distanceBetween, damage
	new Float:playerOrigin[3]
	new maxDamage = get_pcvar_num(gPcvarMaxDamage)
	new FFOn = sh_friendlyfire_on()
	new CsTeams:idTeam = cs_get_user_team(id)

	new players[32], playerCount, player
	get_players(players, playerCount, "ah")

	for ( new i = 0; i < playerCount; i++ ) {
		player = players[i]

		pev(player, pev_origin, playerOrigin)
		distanceBetween = vector_distance(ion_mid_origin[id], playerOrigin)

		if ( distanceBetween <= dmgRadius ) {
			if ( FFOn || player == id || idTeam != cs_get_user_team(player) ) {
				dRatio = distanceBetween / dmgRadius
				damage = maxDamage - floatround(maxDamage * dRatio)
				if ( !damage ) damage = 1	// Incase damage cvar is really low cause something if within the radius
				sh_extra_damage(player, id, damage, "Ion Cannon", _, SH_DMG_NORM, true, _, ion_mid_origin[id])
			}
		}
		message_begin(MSG_ONE_UNRELIABLE, gmsgScreenShake, _, player)
		write_short(255<<14)	// amplitude
		write_short(10<<14)		// duration
		write_short(255<<14)	// frequency
		message_end()
	}
	client_cmd(0, "spk ^"%s^"", gSoundAttack)

	new Float:cooldown = get_pcvar_float(gPcvarCooldown)
	if ( cooldown > 0.0 ) {
		sh_set_cooldown(id, cooldown)

		#if SEND_COOLDOWN
		SecretaryUsedTime[id] = get_gametime()
		#endif
	}

	remove_target(id)
}
//----------------------------------------------------------------------------------------------
remove_target(id)
{
	remove_task(id)
	remove_task(1018+id)
	engfunc(EngFunc_RemoveEntity, g_Target[id])
	g_Target[id] = 0
}
//----------------------------------------------------------------------------------------------
public FM_EmitSound_Pre(id, channel, const sample[], Float:volume, Float:attn, flags, pitch)
{
	if ( !sh_is_active() ) return FMRES_IGNORED
	if ( !is_user_alive(id) || !gHasSecretary[id] || !gHasRadio[id] ) return FMRES_IGNORED

	if ( sample[0] == 'w' && sample[6] == 's' && sample[8] == 'k' && sample[13] == '_' && sample[14] == 'd' ) {
		engfunc(EngFunc_EmitSound, id, channel, gSoundRadioDraw, VOL_NORM, attn, flags, pitch)
		return FMRES_SUPERCEDE
	}
	return FMRES_IGNORED
}
//----------------------------------------------------------------------------------------------
stop_charging(id)
{
	emit_sound(id, CHAN_STATIC, gSoundBeacon, VOL_NORM, ATTN_NORM, SND_STOP, PITCH_NORM)
	progressBar(id, 0)
	remove_task(5000+id)
	gIsCharging[id] = false
}
//----------------------------------------------------------------------------------------------
send_weapon_anim(id, iAnim)
{
	set_pev(id, pev_weaponanim, iAnim)

	message_begin(MSG_ONE_UNRELIABLE, SVC_WEAPONANIM, _, id)
	write_byte(iAnim)
	write_byte(pev(id, pev_body))
	message_end()
}
//----------------------------------------------------------------------------------------------
progressBar(id, seconds)
{
	message_begin(MSG_ONE_UNRELIABLE, gmsgBarTime, _, id)
	write_byte(seconds)
	write_byte(0)
	message_end()
}
//----------------------------------------------------------------------------------------------
// Get entity above sky.
stock Float:tlx_distance_to_sky(id)
{
	new Float:TraceEnd[3]
	pev(id, pev_origin, TraceEnd)

	new Float:f_dest[3]
	f_dest[0] = TraceEnd[0]
	f_dest[1] = TraceEnd[1]
	f_dest[2] = TraceEnd[2] + 8192.0

	new ptr, Float:SkyOrigin[3]
	engfunc(EngFunc_TraceLine, TraceEnd, f_dest, IGNORE_MONSTERS + IGNORE_GLASS, id, ptr)
	get_tr2(ptr, TR_vecEndPos, SkyOrigin)
	free_tr2(ptr)

	return SkyOrigin
}
//----------------------------------------------------------------------------------------------